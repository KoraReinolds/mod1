<!DOCTYPE html>
<html>
<head>
    <title>skunami.js - Two-Way Coupling</title>
    <meta charset="UTF-8"/>

    <link href='http://fonts.googleapis.com/css?family=Fauna+One' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="css/style.css">
    <script type="module">
        import SKULPT from "./js/skulpt/skulpt.js";
        import * as THREE from "../../../build/three.module.js";

        const TERRAIN_RES = 256;
        const TERRAIN_SIZE = 6;
        const PROXY_TERRAIN_RES = 64;
        let terrainImageSettings = {
            'images/igms_679104,4595950,680128,4596974_512.jpg': { 'preblur': 3, 'height': 0.3, 'midGreyIsLowest': true },
            'points': { 'preblur': 0, 'height': TERRAIN_SIZE, 'midGreyIsLowest': false },
            'images/igms_693432,4598934,694456,4599958_512.jpg': { 'preblur': 2, 'height': 0.3, 'midGreyIsLowest': true }
        };
        let options = {
            terrainPoints: [ [10, 10, 10], [10, 5, 5] ],
            terrainImage: Object.keys(terrainImageSettings)[0],
            terrainMidGreyIsLowest: true,
            terrainPreBlur: terrainImageSettings[Object.keys(terrainImageSettings)[0]].preblur,
            terrainHeight: terrainImageSettings[Object.keys(terrainImageSettings)[0]].height,
        };
        let terrainGeom, terrainMesh;
        let renderer, scene, camera, gpuSkulpt;
        let clock = new THREE.Clock();
        let renderTarget = new THREE.WebGLRenderTarget(256, 256);

        function initRenderer() {
            renderer = new THREE.WebGLRenderer({
                antialias : true
            });
            renderer.setSize(window.innerWidth, window.innerHeight - 5);
            renderer.setClearColor('#089119', 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap;
            renderer.shadowMapSoft = true;
            renderer.domElement.id = 'threejs-canvas';
            document.getElementById('threejs-container').append(renderer.domElement);
        }

        function initCamera() {
            camera = new THREE.PerspectiveCamera(25, renderer.domElement.width / renderer.domElement.height, 0.1, 1000);
            camera.position.set(15, 15, 15);
            camera.lookAt(new THREE.Vector3(0, 0, 0));
        }

        
        
        scene = new THREE.Scene();
        //setup lights
        scene.add(new THREE.AmbientLight(0x111111));

        let origImageObj;
        let imageCanvasElemContext;

        function filterTerrainImageAndGenerateHeight() {
            let terrainImageData = imageCanvasElemContext.getImageData(0, 0, TERRAIN_RES, TERRAIN_RES).data;
            // gpuSkulpt.loadFromImageData(terrainImageData, options.terrainHeight, options.terrainMidGreyIsLowest);
        }

        function prepareTerrainImageElements() {
            let imageCanvasElem = document.createElement('canvas');
            imageCanvasElem.id = 'terrainImageCanvas';
            imageCanvasElem.width = TERRAIN_RES;
            imageCanvasElem.height = TERRAIN_RES;
            imageCanvasElemContext = imageCanvasElem.getContext('2d');
            let scaledImageObj = new Image();
            scaledImageObj.id = 'scaledTerrainImage';
            scaledImageObj.onload = function () {
                filterTerrainImageAndGenerateHeight();
            };
            origImageObj = new Image();
            origImageObj.onload = function () {
                imageCanvasElemContext.drawImage(origImageObj, 0, 0, TERRAIN_RES, TERRAIN_RES);
                scaledImageObj.src = imageCanvasElem.toDataURL();
            };
        }

        function loadTerrainImage(image) {
            console.log('Loading terrain image: ' + image);
            origImageObj.src = image;
        }

        function loop() {
            var dt = clock.getDelta();  //have to call this before getElapsedTime()
            renderer.autoClear = false;
            renderer.clear();
            // gpuSkulpt.update(dt);
            // renderer.setRenderTarget(renderTarget);
            renderer.render(scene, camera);

            // renderer.render(scene, camera);
            requestAnimationFrame(loop);
        }
        
        initRenderer()
        initCamera()
        prepareTerrainImageElements();

        terrainGeom = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_RES - 1, TERRAIN_RES - 1);
        terrainGeom.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
        var groundPlaneMaterial = new THREE.MeshBasicMaterial({
            color: 0x99f166
        });

        terrainMesh = new THREE.Mesh(terrainGeom, new THREE.ShaderMaterial({
            uniforms: {
                texture: { type: 'sampler2D', value: renderTarget.texture }
            },
            vertexShader: [
                "varying vec2 vUv;",
                "void main() {",
                "vUv = vec2(uv.x, uv.y);",
                "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
                "}"
            ].join('\n'),
            fragmentShader: [
                "uniform sampler2D texture;",
                "varying vec2 vUv;",

                "void main() {",
                    "vec4 t = texture2D(texture, vUv);",
                    // "t.r += 0.5;",
                    "gl_FragColor = t;",
                "}"
            ].join('\n'),
        }))

        terrainMesh.castShadow = true;
        terrainMesh.receiveShadow = true;
        scene.add(terrainMesh);

        loadTerrainImage(options.terrainImage);

        loop();


    </script>
</head>
<body>
    <div id="threejs-container"></div>
    <div class="translucent" id="info-container">
        <div>Camera: [ Alt+LMB: rotate ] [ Alt+MMB: pan ] [ Alt+RMB: zoom ]</div>
        <div>Sculpt: [ Ctrl+LMB: add ] [ Ctrl+RMB: remove ]</div>
        <div>Water: [ Space+LMB: source ] [ Space+MMB: disturb ] [ Space+RMB: sink ]</div>
        <div>Adding Objects: [ Hold R + Move Mouse: rotate ]</div>
        <div>First Dyn Object: [ W, A, S, D: push ]</div>
    </div>
</body>
</html>